const Editorial = require('../models/Editorial');
const Problem = require('../models/Problem');
const githubService = require('../services/githubService');
const logger = require('../utils/logger');
const { HTTP_STATUS, SUCCESS_MESSAGES } = require('../utils/constants');

class EditorialController {
  // Create editorial
  async createEditorial(req, res, next) {
    try {
      const { problemId } = req.params;
      const {
        content,
        title,
        youtubeLinks,
        approach,
        timeComplexity,
        spaceComplexity,
        codeSnippets,
      } = req.body;

      // Verify problem exists
      const problem = await Problem.findById(problemId);
      if (!problem) {
        return res
          .status(HTTP_STATUS.NOT_FOUND)
          .json({ success: false, message: 'Problem not found' });
      }

      // Create editorial record without content first
      const editorial = new Editorial({
        problemId,
        title,
        content,  // will store markdown content from GitHub only
        youtubeLinks,
        approach,
        timeComplexity,
        spaceComplexity,
        codeSnippets,
        author: req.user.id,
      });

      await editorial.save();

      // Prepare markdown content for GitHub file
      const markdownContent = content;

      // Define file path in repo, e.g., "editorials/{problemId}/{editorialId}.md"
      const filePath = `editorials/${problemId}/${editorial._id}.md`;

      // Save file in GitHub repo (create new file - no SHA needed)
      const result = await githubService.createOrUpdateFile({
        path: filePath,
        content: markdownContent,
        message: `Add editorial for problem ${problemId} - editorial ${editorial._id}`,
      });

      if (!result.success) {
        // Rollback editorial creation on failure to save to GitHub
        await Editorial.findByIdAndDelete(editorial._id);
        return res.status(500).json({
          success: false,
          message: `Failed to save editorial content in GitHub: ${result.error}`,
        });
      }

      // Update editorial with GitHub file path and markdown content
      editorial.githubFilePath = filePath;
      editorial.content = markdownContent;
      await editorial.save();

      // Add editorial reference to problem
      problem.editorials.push(editorial._id);
      await problem.save();

      logger.logActivity(req.user.id, 'editorial_created', 'editorial', {
        editorialId: editorial._id,
        problemId,
      });

      res.status(HTTP_STATUS.CREATED).json({
        success: true,
        message: SUCCESS_MESSAGES.CREATED,
        data: { editorial },
      });
    } catch (error) {
      next(error);
    }
  }

  // Get editorials for a problem
  async getEditorialsByProblem(req, res, next) {
    try {
      const { problemId } = req.params;

      const editorials = await Editorial.find({
        problemId,
        isVisible: true,
      })
        .populate('author', 'name avatar')
        .sort({ createdAt: -1 });

      res.status(HTTP_STATUS.OK).json({
        success: true,
        message: 'Editorials retrieved successfully',
        data: { editorials },
      });
    } catch (error) {
      next(error);
    }
  }

  // Get single editorial
  async getEditorial(req, res, next) {
    try {
      const { id } = req.params;

      const editorial = await Editorial.findById(id)
        .populate('problemId', 'title difficulty')
        .populate('author', 'name avatar')
        .populate('likes', 'name');

      if (!editorial) {
        return res
          .status(HTTP_STATUS.NOT_FOUND)
          .json({ success: false, message: 'Editorial not found' });
      }

      // Fetch GitHub markdown content if available
      let githubContent = null;
      if (editorial.githubFilePath) {
        const result = await githubService.getFileContent(editorial.githubFilePath);

        if (result.success) {
          githubContent = result.content;
        }
      }

      res.status(HTTP_STATUS.OK).json({
        success: true,
        message: 'Editorial retrieved successfully',
        data: {
          editorial,
          githubContent,
        },
      });
    } catch (error) {
      next(error);
    }
  }

  // Update editorial - FIXED VERSION
  async updateEditorial(req, res, next) {
    try {
      const { id } = req.params;
      const {
        content,
        title,
        youtubeLinks,
        approach,
        timeComplexity,
        spaceComplexity,
        codeSnippets,
        isVisible,
      } = req.body;

      const editorial = await Editorial.findById(id);
      if (!editorial) {
        return res
          .status(HTTP_STATUS.NOT_FOUND)
          .json({ success: false, message: 'Editorial not found' });
      }

      // Check if user is author or has permission
      if (
        editorial.author.toString() !== req.user.id &&
        !['Admin', 'Developer'].includes(req.user.role)
      ) {
        return res
          .status(HTTP_STATUS.FORBIDDEN)
          .json({ success: false, message: 'Not authorized to update this editorial' });
      }

      // Update fields locally first
      if (title !== undefined) editorial.title = title;
      if (youtubeLinks !== undefined) editorial.youtubeLinks = youtubeLinks;
      if (approach !== undefined) editorial.approach = approach;
      if (timeComplexity !== undefined) editorial.timeComplexity = timeComplexity;
      if (spaceComplexity !== undefined) editorial.spaceComplexity = spaceComplexity;
      if (codeSnippets !== undefined) editorial.codeSnippets = codeSnippets;
      if (isVisible !== undefined) editorial.isVisible = isVisible;

      // If content is updated, push to GitHub file as well
      if (content !== undefined) {
        const filePath = editorial.githubFilePath;
        if (!filePath) {
          // Define file path if missing (fallback)
          editorial.githubFilePath = `editorials/${editorial.problemId}/${editorial._id}.md`;
        }

        // **FIX: Get the current file's SHA before updating**
        let sha = null;
        if (editorial.githubFilePath) {
          try {
            // First, get the current file metadata to retrieve the SHA
            const fileMetadata = await githubService.getFileContent(editorial.githubFilePath);
            if (fileMetadata.success && fileMetadata.sha) {
              sha = fileMetadata.sha;
            }
          } catch (metadataError) {
            // If file doesn't exist yet, sha remains null (for creating new file)
            console.warn('File metadata not found, will create new file:', metadataError.message);
          }
        }

        // Update GitHub file content with SHA
        const result = await githubService.createOrUpdateFile({
          path: editorial.githubFilePath,
          content,
          message: `Update editorial for problem ${editorial.problemId} - editorial ${editorial._id}`,
          sha, // Pass the SHA here - required for updates, optional for creates
        });

        if (!result.success) {
          return res.status(500).json({
            success: false,
            message: `Failed to update editorial content in GitHub: ${result.error}`,
          });
        }

        editorial.content = content;
      }

      await editorial.save();

      res.status(HTTP_STATUS.OK).json({
        success: true,
        message: SUCCESS_MESSAGES.UPDATED,
        data: { editorial },
      });
    } catch (error) {
      next(error);
    }
  }

  // Delete editorial
  async deleteEditorial(req, res, next) {
    try {
      const { id } = req.params;

      const editorial = await Editorial.findById(id);
      if (!editorial) {
        return res
          .status(HTTP_STATUS.NOT_FOUND)
          .json({ success: false, message: 'Editorial not found' });
      }

      // Check permissions
      if (
        editorial.author.toString() !== req.user.id &&
        !['Admin', 'Developer'].includes(req.user.role)
      ) {
        return res
          .status(HTTP_STATUS.FORBIDDEN)
          .json({ success: false, message: 'Not authorized to delete this editorial' });
      }

      // Remove editorial ref from problem
      await Problem.findByIdAndUpdate(editorial.problemId, {
        $pull: { editorials: id },
      });

      // Optionally delete file from GitHub (you can implement this in githubService if needed)

      await Editorial.findByIdAndDelete(id);

      res.status(HTTP_STATUS.OK).json({
        success: true,
        message: SUCCESS_MESSAGES.DELETED,
      });
    } catch (error) {
      next(error);
    }
  }

  // Like/Unlike editorial
  async toggleLike(req, res, next) {
    try {
      const { id } = req.params;
      const userId = req.user.id;

      const editorial = await Editorial.findById(id);
      if (!editorial) {
        return res
          .status(HTTP_STATUS.NOT_FOUND)
          .json({ success: false, message: 'Editorial not found' });
      }

      const isLiked = editorial.likes.includes(userId);

      if (isLiked) {
        editorial.likes.pull(userId);
      } else {
        editorial.likes.push(userId);
      }

      await editorial.save();

      res.status(HTTP_STATUS.OK).json({
        success: true,
        message: isLiked ? 'Editorial unliked' : 'Editorial liked',
        data: {
          liked: !isLiked,
          likesCount: editorial.likes.length,
        },
      });
    } catch (error) {
      next(error);
    }
  }
}

module.exports = new EditorialController();
